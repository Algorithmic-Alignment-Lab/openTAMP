Index: opentamp/bash_scripts/eval_baselines.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>python3 -W ignore policy_hooks/run_training.py \\\n        -c policy_hooks.namo.hyperparams_v93 \\\n        -no 1 -nt 1 \\\n        --expert_path tf_saved/namo_objs1_1/exp_id0_data_gen_0/ \\\n        -baseline gail \\\n        --traj_limitation 10 \\\n        --index 0 \\\n        -ref_key gail_baseline \\\n        --task evaluate \\\n        --num_timesteps 500000 \\\n        --episode_timesteps 200\\\n        -descr gail_baseline_1obj_trajectories\n\n
===================================================================
diff --git a/opentamp/bash_scripts/eval_baselines.sh b/opentamp/bash_scripts/eval_baselines.sh
--- a/opentamp/bash_scripts/eval_baselines.sh	
+++ b/opentamp/bash_scripts/eval_baselines.sh	
@@ -1,4 +1,4 @@
-python3 -W ignore policy_hooks/run_training.py \
+/Users/phillipchristoffersen/opt/anaconda3/envs/openTAMP/bin/python3 -W ignore policy_hooks/run_training.py \
         -c policy_hooks.namo.hyperparams_v93 \
         -no 1 -nt 1 \
         --expert_path tf_saved/namo_objs1_1/exp_id0_data_gen_0/ \
@@ -10,4 +10,3 @@
         --num_timesteps 500000 \
         --episode_timesteps 200\
         -descr gail_baseline_1obj_trajectories
-
Index: opentamp/robo_wiping.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nimport sys\nimport time\n\nimport numpy as np\nimport pybullet as P\nimport robosuite\nimport robosuite.utils.transform_utils as robo_T\nfrom robosuite.controllers import load_controller_config\nfrom scipy.spatial.transform import Rotation\n\nimport opentamp.core.util_classes.transform_utils as T\nimport main\nfrom opentamp.core.parsing import parse_domain_config, parse_problem_config\nfrom opentamp.core.util_classes.openrave_body import *\nfrom opentamp.core.util_classes.transform_utils import *\nfrom opentamp.core.util_classes.viewer import PyBulletViewer\nfrom pma import backtrack_ll_solver_gurobi as bt_ll\nfrom pma.hl_solver import *\nfrom pma.pr_graph import *\nfrom pma.robosuite_solver import RobotSolver\nfrom sco_py.expr import *\nimport random\n\n\nrandom.seed(23)\nREF_QUAT = np.array([0, 0, -0.7071, -0.7071])\n\n\ndef theta_error(cur_quat, next_quat):\n    sign1 = np.sign(cur_quat[np.argmax(np.abs(cur_quat))])\n    sign2 = np.sign(next_quat[np.argmax(np.abs(next_quat))])\n    next_quat = np.array(next_quat)\n    cur_quat = np.array(cur_quat)\n    angle = -(sign1 * sign2) * robo_T.get_orientation_error(\n        sign1 * next_quat, sign2 * cur_quat\n    )\n    return angle\n\n\n# controller_config = load_controller_config(default_controller=\"OSC_POSE\")\n# controller_config = load_controller_config(default_controller=\"JOINT_VELOCITY\")\n# controller_config['control_delta'] = False\n# controller_config['kp'] = 500\n# controller_config['kp'] = [750, 750, 500, 5000, 5000, 5000]\n\nctrl_mode = \"JOINT_POSITION\"\ntrue_mode = \"JOINT\"\n\n# ctrl_mode = 'OSC_POSE'\n# true_mode = 'IK'\n\ncontroller_config = load_controller_config(default_controller=ctrl_mode)\nif ctrl_mode.find(\"JOINT\") >= 0:\n    controller_config[\"kp\"] = [7500, 6500, 6500, 6500, 6500, 6500, 12000]\n    controller_config[\"output_max\"] = 0.2\n    controller_config[\"output_min\"] = -0.2\nelse:\n    controller_config[\"kp\"] = 5000  # [8000, 8000, 8000, 4000, 4000, 4000]\n    controller_config[\"input_max\"] = 0.2  # [0.05, 0.05, 0.05, 4, 4, 4]\n    controller_config[\"input_min\"] = -0.2  # [-0.05, -0.05, -0.05, -4, -4, -4]\n    controller_config[\"output_max\"] = 0.02  # [0.1, 0.1, 0.1, 2, 2, 2]\n    controller_config[\"output_min\"] = -0.02  # [-0.1, -0.1, -0.1, -2, -2, -2]\n\n\nvisual = len(os.environ.get(\"DISPLAY\", \"\")) > 0\nhas_render = visual\nobj_mode = 2\nenv = robosuite.make(\n    \"Wipe\",\n    robots=[\"Sawyer\"],             # load a Sawyer robot\n    controller_configs=controller_config,   # each arm is controlled using OSC\n    has_renderer=has_render,                      # on-screen rendering\n    render_camera=\"frontview\",              # visualize the \"frontview\" camera\n    has_offscreen_renderer=(not has_render),           # no off-screen rendering\n    control_freq=50,                        # 50 hz control for applied actions\n    horizon=200,                            # each episode terminates after 200 steps\n    use_object_obs=True,                   # no observations needed\n    use_camera_obs=False,                   # no observations needed\n    ignore_done=True,\n    reward_shaping=True,\n    initialization_noise={'magnitude': 0., 'type': 'gaussian'},\n    camera_widths=128,\n    camera_heights=128,\n)\nobs, _, _, _ = env.step(np.zeros(7)) # Step a null action to 'boot' the environment.\n# wipe_centroid_pose = obs['wipe_centroid']\n\n# Get the locations of all dirt particles\ndirt_locs = np.zeros((env.num_markers, 3))\nfor i, marker in enumerate(env.model.mujoco_arena.markers):\n    marker_pos = np.array(env.sim.data.body_xpos[env.sim.model.body_name2id(marker.root_body)])\n    dirt_locs[i,:] = marker_pos\n\n# First, we reset the environment and then manually set the joint positions to their\n# initial positions and all the joint velocities and accelerations to 0.\nobs = env.reset()\njnts = env.sim.data.qpos[:7]\nfor _ in range(40):\n    env.step(np.zeros(7))\n    env.sim.data.qpos[:7] = jnts\n    env.sim.forward()\nenv.sim.data.qvel[:] = 0\nenv.sim.data.qacc[:] = 0\nenv.sim.forward()\n\nbt_ll.DEBUG = True\nopenrave_bodies = None\ndomain_fname = os.getcwd() + \"/opentamp/domains/robot_wiping_domain/right_wipe_onlytable.domain\"\nprob = os.getcwd() + \"/opentamp/domains/robot_wiping_domain/probs/simple_move_onlytable_prob.prob\"\nd_c = main.parse_file_to_dict(domain_fname)\ndomain = parse_domain_config.ParseDomainConfig.parse(d_c)\nhls = FFSolver(d_c)\np_c = main.parse_file_to_dict(prob)\nvisual = len(os.environ.get('DISPLAY', '')) > 0\nproblem = parse_problem_config.ParseProblemConfig.parse(p_c, domain, None, use_tf=True, sess=None, visual=visual)\nparams = problem.init_state.params\nbody_ind = env.mjpy_model.body_name2id(\"robot0_base\")\n\n# Resetting the initial state to specific values\nparams[\"sawyer\"].pose[:, 0] = env.sim.data.body_xpos[body_ind]\n\njnts = params[\"sawyer\"].geom.jnt_names[\"right\"]\njnts = [\"robot0_\" + jnt for jnt in jnts]\njnt_vals = []\nsawyer_inds = []\nfor jnt in jnts:\n    jnt_adr = env.mjpy_model.joint_name2id(jnt)\n    jnt_ind = env.mjpy_model.jnt_qposadr[jnt_adr]\n    sawyer_inds.append(jnt_ind)\n    jnt_vals.append(env.sim.data.qpos[jnt_ind])\nparams[\"sawyer\"].right[:, 0] = jnt_vals\nparams[\"sawyer\"].openrave_body.set_pose(params[\"sawyer\"].pose[:, 0])\nparams[\"sawyer\"].openrave_body.set_dof({\"right\": params[\"sawyer\"].right[:, 0]})\ninfo = params[\"sawyer\"].openrave_body.fwd_kinematics(\"right\")\nparams[\"sawyer\"].right_ee_pos[:, 0] = info[\"pos\"]\nparams[\"sawyer\"].right_ee_pos[:, 0] = T.quaternion_to_euler(info[\"quat\"], \"xyzw\")\n\n\ngoal = \"(RobotAt sawyer region_pose5_5)\"\n# goal = \"(InContactRobotTable sawyer table)\"\n# goal = \"(WipedSurface sawyer) (InContactRobotTable sawyer table)\"\nsolver = RobotSolver()\nplan, descr = p_mod_abs(\n    hls, solver, domain, problem, goal=goal, debug=True, n_resamples=10\n)\n\nif len(sys.argv) > 1 and sys.argv[1] == \"end\":\n    sys.exit(0)\n\nif plan is None:\n    print(\"Could not find plan; terminating.\")\n    sys.exit(1)\n\nsawyer = plan.params[\"sawyer\"]\ncmds = []\nfor t in range(plan.horizon):\n    rgrip = sawyer.right_gripper[0, t]\n    if true_mode.find(\"JOINT\") >= 0:\n        act = np.r_[sawyer.right[:, t]]\n    else:\n        pos, euler = sawyer.right_ee_pos[:, t], sawyer.right_ee_rot[:, t]\n        quat = np.array(T.euler_to_quaternion(euler, \"xyzw\"))\n        # angle = robosuite.utils.transform_utils.quat2axisangle(quat)\n        rgrip = sawyer.right_gripper[0, t]\n        act = np.r_[pos, quat]\n        # act = np.r_[pos, angle, [-rgrip]]\n        # act = np.r_[sawyer.right[:,t], [-rgrip]]\n    cmds.append(act)\n\ngrip_ind = env.mjpy_model.site_name2id(\"gripper0_grip_site\")\nhand_ind = env.mjpy_model.body_name2id(\"robot0_right_hand\")\nenv.reset()\nenv.sim.data.qpos[:7] = params[\"sawyer\"].right[:, 0]\nenv.sim.data.qacc[:] = 0\nenv.sim.data.qvel[:] = 0\nenv.sim.forward()\nrot_ref = T.euler_to_quaternion(params[\"sawyer\"].right_ee_rot[:, 0], \"xyzw\")\n\nfor _ in range(40):\n    env.step(np.zeros(7))\n    env.sim.data.qpos[:7] = params[\"sawyer\"].right[:, 0]\n    env.sim.forward()\n\n\nnsteps = 60\ncur_ind = 0\n\ntol = 1e-3\n\ntrue_lb, true_ub = plan.params[\"sawyer\"].geom.get_joint_limits(\"right\")\nfactor = (np.array(true_ub) - np.array(true_lb)) / 5\nref_jnts = env.sim.data.qpos[:7]\nref_jnts = np.array([0, -np.pi / 4, 0, np.pi / 4, 0, np.pi / 2, 0])\nfor act in plan.actions:\n    t = act.active_timesteps[0]\n    plan.params[\"sawyer\"].right[:, t] = env.sim.data.qpos[:7]\n    grip = env.sim.data.qpos[7:9].copy()\n    failed_preds = plan.get_failed_preds(active_ts=(t, t), priority=3, tol=tol)\n    oldqfrc = env.sim.data.qfrc_applied[:]\n    oldxfrc = env.sim.data.xfrc_applied[:]\n    oldacc = env.sim.data.qacc[:]\n    oldvel = env.sim.data.qvel[:]\n    oldwarm = env.sim.data.qacc_warmstart[:]\n    oldctrl = env.sim.data.ctrl[:]\n    # failed_preds = [p for p in failed_preds if (p[1]._rollout or not type(p[1].expr) is EqExpr)]\n    print(\"FAILED:\", t, failed_preds, act.name)\n    old_state = env.sim.get_state()\n    # env.sim.reset()\n    # env.sim.data.qpos[:7] = plan.params['sawyer'].right[:,t]\n    # env.sim.data.qpos[cereal_ind:cereal_ind+3] = plan.params['cereal'].pose[:,t]\n    # env.sim.data.qpos[cereal_ind+3:cereal_ind+7] = cereal_quat\n    # env.sim.data.qpos[7:9] = grip\n    # env.sim.data.qacc[:] = 0. #oldacc\n    # env.sim.data.qacc_warmstart[:] = 0.#oldwarm\n    # env.sim.data.qvel[:] = 0.\n    # env.sim.data.ctrl[:] = 0.#oldctrl\n    # env.sim.data.qfrc_applied[:] = 0.#oldqfrc\n    # env.sim.data.xfrc_applied[:] = 0.#oldxfrc\n    # env.sim.forward()\n    # env.sim.set_state(old_state)\n    # env.sim.forward()\n\n    sawyer = plan.params[\"sawyer\"]\n    for t in range(act.active_timesteps[0], act.active_timesteps[1]):\n        base_act = cmds[cur_ind]\n        cur_ind += 1\n        print(\"TIME:\", t)\n        init_jnts = env.sim.data.qpos[:7]\n        if ctrl_mode.find(\"JOINT\") >= 0 and true_mode.find(\"JOINT\") < 0:\n            cur_jnts = env.sim.data.qpos[:7]\n            if t < plan.horizon:\n                targ_pos, targ_rot = (\n                    sawyer.right_ee_pos[:, t + 1],\n                    sawyer.right_ee_rot[:, t + 1],\n                )\n            else:\n                targ_pos, targ_rot = (\n                    sawyer.right_ee_pos[:, t],\n                    sawyer.right_ee_rot[:, t],\n                )\n            lb = env.sim.data.qpos[:7] - factor\n            ub = env.sim.data.qpos[:7] + factor\n            sawyer.openrave_body.set_dof({\"right\": np.zeros(7)})\n            sawyer.openrave_body.set_dof({\"right\": ref_jnts})\n\n            targ_jnts = sawyer.openrave_body.get_ik_from_pose(\n                targ_pos, targ_rot, \"right\", bnds=(lb, ub)\n            )\n            base_act = np.r_[targ_jnts, base_act[-1]]\n\n        true_act = base_act.copy()\n        if ctrl_mode.find(\"JOINT\") >= 0:\n            targ_jnts = base_act[:7]  # + env.sim.data.qpos[:7]\n            for n in range(nsteps):\n                act = base_act.copy()\n                act[:7] = targ_jnts - env.sim.data.qpos[:7]\n                obs = env.step(act)\n            end_jnts = env.sim.data.qpos[:7]\n\n            ee_to_sim_discrepancy = (\n                env.sim.data.site_xpos[grip_ind] - sawyer.right_ee_pos[:, t]\n            )\n\n            print(\n                \"EE PLAN VS SIM:\",\n                ee_to_sim_discrepancy,\n                t,\n            )\n\n            # if ee_to_sim_discrepancy[2] > 0.01:\n            #     from IPython import embed; embed()\n\n            # print('\\n\\n\\n')\n\n        else:\n            targ = base_act[3:7]\n            cur = env.sim.data.body_xquat[hand_ind]\n            cur = np.array([cur[1], cur[2], cur[3], cur[0]])\n            truerot = Rotation.from_quat(targ)\n            currot = Rotation.from_quat(cur)\n            base_angle = (truerot * currot.inv()).as_rotvec()\n            # base_angle = robosuite.utils.transform_utils.get_orientation_error(sign*targ, cur)\n            rot = Rotation.from_rotvec(base_angle)\n            targrot = (rot * currot).as_quat()\n            # print('TARGETS:', targ, targrot)\n            for n in range(nsteps):\n                act = base_act.copy()\n                act[:3] -= env.sim.data.site_xpos[grip_ind]\n                # act[:3] *= 1e2\n                cur = env.sim.data.body_xquat[hand_ind]\n                cur = np.array([cur[1], cur[2], cur[3], cur[0]])\n                # targ = act[3:7]\n                sign = np.sign(targ[np.argmax(np.abs(targrot))])\n                cur_sign = np.sign(targ[np.argmax(np.abs(cur))])\n                targ = targrot\n                # if sign != cur_sign:\n                #    sign = -1.\n                # else:\n                #    sign = 1.\n                rotmult = 1e0  # 1e1\n                ##angle = 5e2*theta_error(cur, targ) #robosuite.utils.transform_utils.get_orientation_error(sign*targ, cur)\n                # angle = robosuite.utils.transform_utils.get_orientation_error(sign*targ, cur)\n                # rot = Rotation.from_rotvec(angle)\n                # currot = Rotation.from_quat(cur)\n                angle = (\n                    -rotmult\n                    * sign\n                    * cur_sign\n                    * robosuite.utils.transform_utils.get_orientation_error(\n                        sign * targrot, cur_sign * cur\n                    )\n                )\n                # a = np.linalg.norm(angle)\n                # if a > 2*np.pi:\n                #    angle = (a - 2*np.pi)  * angle / a\n                act = np.r_[act[:3], angle, act[-1:]]\n                # act[3:6] -= robosuite.utils.transform_utils.quat2axisangle(cur)\n                # act[:7] = (act[:7] - np.array([env.sim.data.qpos[ind] for ind in sawyer_inds]))\n                obs = env.step(act)\n            print('EE PLAN VS SIM:', env.sim.data.site_xpos[grip_ind]-sawyer.right_ee_pos[:,t], t, env.reward())\n        if has_render: env.render()\nplan.params['sawyer'].right[:,t] = env.sim.data.qpos[:7]\n
===================================================================
diff --git a/opentamp/robo_wiping.py b/opentamp/robo_wiping.py
--- a/opentamp/robo_wiping.py	
+++ b/opentamp/robo_wiping.py	
@@ -83,7 +83,7 @@
     camera_widths=128,
     camera_heights=128,
 )
-obs, _, _, _ = env.step(np.zeros(7)) # Step a null action to 'boot' the environment.
+obs, _, _, _ = env.step(np.zeros(7))  # Step a null action to 'boot' the environment.
 # wipe_centroid_pose = obs['wipe_centroid']
 
 # Get the locations of all dirt particles
Index: opentamp/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import argparse, traceback\nfrom opentamp.errors_exceptions import OpenTAMPException\nfrom opentamp.pma import pr_graph\n\n\"\"\"\nEntry-level script. Calls pr_graph.p_mod_abs() to plan, then runs the plans in\nsimulation using the chosen viewer.\n\"\"\"\n\ncache = {}\ndef parse_file_to_dict(f_name):\n    d = {}\n    if f_name in cache:\n        return cache[f_name].copy()\n    with open(f_name, \"r\") as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith(\"#\"):\n                if len(line.split(\":\", 1)) != 2: import ipdb; ipdb.set_trace()\n                k, v = line.split(\":\", 1)\n                d[k.strip()] = v.strip()\n        f.close()\n    cache[f_name] = d\n    return d.copy()\n\ndef main(domain_file, problem_file, solvers_file):\n    try:\n        domain_config = parse_file_to_dict(domain_file)\n        problem_config = parse_file_to_dict(problem_file)\n        solvers_config = parse_file_to_dict(solvers_file)\n        plan, msg = pr_graph.p_mod_abs(domain_config, problem_config, solvers_config)\n        if plan:\n            print(\"Executing plan!\")\n            plan.execute()\n        else:\n            print(msg)\n    except OpenTAMPException as e:\n        print(\"Caught an exception in OpenTAMP:\")\n        traceback.print_exc()\n        print(\"Terminating...\")\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Run OpenTAMP.\")\n    parser.add_argument(\"domain_file\",\n                        help=\"Path to the domain file to use. All domain settings should be specified in this file.\")\n    parser.add_argument(\"problem_file\",\n                        help=\"Path to the problem file to use. All problem settings should be specified in this file. Spawned by a generate_*_prob.py script.\")\n    parser.add_argument(\"solvers_file\",\n                        help=\"Path to the file naming the solvers to use. The HLSolver and LLSolver to use should be specified here.\")\n    args = parser.parse_args()\n    main(args.domain_file, args.problem_file, args.solvers_file)\n
===================================================================
diff --git a/opentamp/main.py b/opentamp/main.py
--- a/opentamp/main.py	
+++ b/opentamp/main.py	
@@ -39,6 +39,7 @@
         traceback.print_exc()
         print("Terminating...")
 
+
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description="Run OpenTAMP.")
     parser.add_argument("domain_file",
Index: opentamp/bash_scripts/run_baselines.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>for N in 1 2 3 4 5\ndo\n    for S in third\n    do\n\n\n        python3 -W ignore policy_hooks/run_training_spawn.py -c policy_hooks.namo.flathyp \\\n                                                       -no 1 -llus 5000  -hlus 5000 \\\n                                                       -spl -mask -hln 2 -hldim 96 -lldim 64 \\\n                                                       -retime -vel 0.3 -eta 5 -softev \\\n                                                       -hist_len 2 -prim_first_wt 20 -lr 0.0002 \\\n                                                       -hllr 0.001 -lldec 0.0001 -hldec 0.0004 \\\n                                                       -add_noop 0 --permute_hl 1 \\\n                                                       -col_coeff 0.0 \\\n                                                       -motion 0 \\\n                                                       -rollout 0 \\\n                                                       -task 0 \\\n                                                       -warm 100 \\\n                                                       -run_baseline \\\n                                                       -baseline stable \\\n                                                       -render \\\n                                                       --total_timesteps 4000000 \\\n                                                       --n_proc 32 \\\n                                                       -flat \\\n                                                       --algo ppo2 \\\n                                                       -descr 2d_pickplace_1obj_PPO2 &\n\n        sleep 12h \n        pkill -f run_train -9\n        pkill -f ros -9\n        sleep 5s\n\n    done\ndone\n\n
===================================================================
diff --git a/opentamp/bash_scripts/run_baselines.sh b/opentamp/bash_scripts/run_baselines.sh
--- a/opentamp/bash_scripts/run_baselines.sh	
+++ b/opentamp/bash_scripts/run_baselines.sh	
@@ -2,9 +2,7 @@
 do
     for S in third
     do
-
-
-        python3 -W ignore policy_hooks/run_training_spawn.py -c policy_hooks.namo.flathyp \
+         /Users/phillipchristoffersen/opt/anaconda3/envs/openTAMP/bin/python -W ignore policy_hooks/run_training_spawn.py -c policy_hooks.namo.flathyp \
                                                        -no 1 -llus 5000  -hlus 5000 \
                                                        -spl -mask -hln 2 -hldim 96 -lldim 64 \
                                                        -retime -vel 0.3 -eta 5 -softev \
@@ -25,10 +23,10 @@
                                                        --algo ppo2 \
                                                        -descr 2d_pickplace_1obj_PPO2 &
 
-        sleep 12h 
-        pkill -f run_train -9
-        pkill -f ros -9
-        sleep 5s
+#        sleep 12h
+#        pkill -f run_train -9
+#        pkill -f ros -9
+#        sleep 5
 
     done
 done
Index: opentamp/debug_scripts/test_grip_det.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import warnings\nwarnings.filterwarnings(\"ignore\", message=r\"Passing\", category=FutureWarning)\n\nimport argparse\nimport itertools\nimport os\n\nimport opentamp.main as main\nfrom opentamp.core.parsing import parse_domain_config, parse_problem_config\nfrom opentamp.envs import MJCEnv\nimport opentamp.policy_hooks.namo.sorting_prob_11 as prob_gen\nfrom opentamp.pma.namo_grip_solver import NAMOSolverOSQP#, NAMOSolverGurobi\nfrom opentamp.pma.hl_solver import *\nfrom opentamp.pma.pr_graph import *\nfrom opentamp.pma import backtrack_ll_solver_OSQP as bt_ll_osqp\n#from opentamp.pma import backtrack_ll_solver_gurobi as bt_ll_gurobi\nfrom opentamp.core.util_classes.openrave_body import OpenRAVEBody\nfrom opentamp.policy_hooks.utils.policy_solver_utils import *\n\n\nprob_gen.NUM_OBJS = 2\nprob_gen.FIX_TARGETS = True\nprob_gen.n_aux = 0\nprob_gen.END_TARGETS = prob_gen.END_TARGETS[:8]\nprob_gen.domain_file = os.getcwd() + '/opentamp' + \"/domains/namo_domain/namo_current_holgrip.domain\"\n#bt_ll_gurobi.DEBUG = True \n#bt_ll_gurobi.COL_COEFF = 0.01\nbt_ll_osqp.DEBUG = True\nbt_ll_osqp.COL_COEFF = 0.005\nN_OBJS = 2\nvisual = len(os.environ.get('DISPLAY', '')) > 0\nd_c = main.parse_file_to_dict(prob_gen.domain_file)\ndomain = parse_domain_config.ParseDomainConfig.parse(d_c)\nprob_file = os.getcwd() + '/opentamp' + \"/domains/namo_domain/namo_probs/grip_prob_{}_8end_0aux.prob\".format(N_OBJS)\ngoal = '(and '\np_c = main.parse_file_to_dict(prob_file)\nproblem = parse_problem_config.ParseProblemConfig.parse(p_c, domain, None, visual=visual)\n\npossible_can_locs = list(itertools.product(list(range(-70, 70, 4)), list(range(-60, 0, 4))))\nparams = problem.init_state.params\ninds = [52, 478, 382]\ntarg_inds = list(range(8))\n\nparams['obs0'].pose[:,0] = [-3.5, 0.]\nparams['pr2'].pose[:,0] = np.array(possible_can_locs[inds[-1]]) / 10.\nfor n in range(len(prob_gen.END_TARGETS)):\n    params['end_target_{}'.format(n)].value[:,0] = prob_gen.END_TARGETS[n]\n\nfor n in range(N_OBJS):\n    params['can{}'.format(n)].pose[:,0] = np.array(possible_can_locs[inds[n]]) / 10.\n    goal += '(Near can{} end_target_{})'.format(n, targ_inds[n])\ngoal += ')'\n\nfor pname in params:\n    targ = '{}_init_target'.format(pname)\n    if targ in params:\n        params[targ].value[:,0] = params[pname].pose[:,0]\n\n# NOTE: To use Gurobi instead of OSQP, simply replace the below line with:\n# solver = NAMOSolverGurobi()\nsolver = NAMOSolverOSQP()\n\nUSE_FF = False\nif USE_FF:\n    hls = FFSolver(d_c)\nelse:\n    hls = FDSolver(d_c)\n    \nplan, descr = p_mod_abs(hls, solver, domain, problem, goal=goal, debug=True, n_resamples=5)\n\nif plan is None:\n    exit()\n\nfpath = os.getcwd() + '/opentamp'\nact_jnts = ['robot_x', 'robot_y', 'robot_theta', 'left_finger_joint', 'right_finger_joint']\nitems = []\nfname = fpath+'/robot_info/lidar_namo.xml'\ncolors = [[1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 1, 1], [0.7, 0.7, 0.1, 1], [1., 0.1, 0.8, 1], [0.5, 0.95, 0.5, 1], [0.75, 0.4, 0, 1], [0.25, 0.25, 0.5, 1], [0.5, 0, 0.25, 1], [0, 0.5, 0.75, 1], [0, 0, 0.5, 1]]\nfor n in range(N_OBJS):\n    cur_color = colors.pop(0)\n    targ_color = cur_color[:3] + [1.]\n    targ_pos = np.r_[plan.params['can{}'.format(n)].pose[:,-1], -0.15]\n    items.append({'name': 'can{}'.format(n), 'type': 'cylinder', 'is_fixed': False, 'pos': (0, 1.5, 0.5), 'dimensions': (0.3, 0.2), 'mass': 40., 'rgba': tuple(cur_color)})\n    items.append({'name': 'can{0}_end_target'.format(n), 'type': 'box', 'is_fixed': True, 'pos': targ_pos, 'dimensions': (0.35, 0.35, 0.045), 'rgba': tuple(targ_color), 'mass': 1.})\n\nwall_dims = OpenRAVEBody.get_wall_dims('closet')\nfor i in range(len(wall_dims)):\n    dim, next_trans = wall_dims[i]\n    next_trans[0,3] -= 3.5\n    next_dim = dim # [dim[1], dim[0], dim[2]]\n    pos = next_trans[:3,3] # [next_trans[1,3], next_trans[0,3], next_trans[2,3]]\n    items.append({'name': 'wall{0}'.format(i), 'type': 'box', 'is_fixed': True, 'pos': pos, 'dimensions': next_dim, 'rgba': (0.2, 0.2, 0.2, 1)})\n\nconfig = {'include_files': [fname], 'sim_freq': 50, 'include_items': items, 'act_jnts': act_jnts, 'step_mult': 5e0, 'view': visual, 'timestep': 0.002, 'load_render': True}\nenv = MJCEnv.load_config(config)\npr2 = plan.params['pr2']\nxval, yval = pr2.pose[:,0]\ngrip = pr2.gripper[0,0]\ntheta = pr2.theta[0,0]\nenv.set_joints({'robot_x': xval, 'robot_y': yval, 'left_finger_joint': grip, 'right_finger_joint': grip, 'robot_theta': theta}, forward=False)\nfor n in range(N_OBJS):\n    pname = 'can{}'.format(n)\n    param = plan.params[pname]\n    env.set_item_pos(pname, np.r_[param.pose[:,0], 0.5])\n\nfor t in range(plan.horizon-1):\n    cur_x, cur_y, _ = env.get_item_pos('pr2')\n    cur_theta = env.get_joints(['robot_theta'])['robot_theta'][0]\n    cmd_x, cmd_y = pr2.pose[:,t+1] - [cur_x, cur_y]\n    cmd_theta = pr2.theta[0,t+1] - cur_theta\n    gripper = pr2.gripper[0,t]\n    gripper = -0.1 if gripper < 0 else 0.1\n\n    vel_ratio = 0.05\n    nsteps = int(max(abs(cmd_x), abs(cmd_y)) / vel_ratio) + 1\n    for n in range(nsteps):\n        x = cur_x + float(n)/nsteps * cmd_x\n        y = cur_y + float(n)/nsteps * cmd_y\n        theta = cur_theta + float(n)/nsteps * cmd_theta\n        ctrl_vec = np.array([x, y, theta, 5*gripper, 5*gripper])\n        env.step(ctrl_vec, mode='velocity', gen_obs=False)\n    ctrl_vec = np.array([cur_x+cmd_x, cur_y+cmd_y, cur_theta+cmd_theta, 5*gripper, 5*gripper])\n    env.step(ctrl_vec, mode='velocity')\n    env.step(ctrl_vec, mode='velocity')\n    if visual:\n        env.render(camera_id=0, height=256, width=256, view=True)\n
===================================================================
diff --git a/opentamp/debug_scripts/test_grip_det.py b/opentamp/debug_scripts/test_grip_det.py
--- a/opentamp/debug_scripts/test_grip_det.py	
+++ b/opentamp/debug_scripts/test_grip_det.py	
@@ -124,3 +124,4 @@
     env.step(ctrl_vec, mode='velocity')
     if visual:
         env.render(camera_id=0, height=256, width=256, view=True)
+        print('reached')
